#!/usr/bin/env python3
"""
Mundi Engine - Lua 바인딩 자동 생성 도구

UPROPERTY와 UFUNCTION 매크로를 파싱하여
.generated.cpp 파일을 자동 생성합니다.

사용법:
    python generate.py --source-dir <소스 디렉토리> --output-dir <출력 디렉토리>
"""

import argparse
import sys
import os
from pathlib import Path
import subprocess

# Add current script directory to Python path
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from header_parser import HeaderParser
from property_generator import PropertyGenerator
from lua_generator import LuaBindingGenerator
import re


def pascal_case_to_upper_snake(name: str) -> str:
    """
    PascalCase를 UPPER_SNAKE_CASE로 변환
    AActor -> A_ACTOR
    UActorComponent -> U_ACTOR_COMPONENT
    """
    # 대문자 앞에 언더스코어 삽입 (첫 글자 제외)
    result = re.sub(r'(?<!^)(?=[A-Z])', '_', name)
    return result.upper()


GENERATED_HEADER_TEMPLATE = """// Auto-generated file - DO NOT EDIT!
// Generated by Tools/CodeGenerator/generate.py

#pragma once

// Macro expansion for GENERATED_REFLECTION_BODY()
// This file must be included BEFORE the class definition

// Undefine previous class's macro if exists
#ifdef CURRENT_CLASS_GENERATED_BODY
#undef CURRENT_CLASS_GENERATED_BODY
#endif

// Define class-specific body macro
#define {macro_name}_BODY \\
public: \\
    using Super = {parent_class}; \\
    using ThisClass_t = {class_name}; \\
    static UClass* StaticClass() \\
    {{ \\
        static UClass Cls{{ "{class_name}", {parent_class}::StaticClass(), sizeof({class_name}) }}; \\
        static bool bRegistered = (UClass::SignUpClass(&Cls), true); \\
        return &Cls; \\
    }} \\
    virtual UClass* GetClass() const override {{ return {class_name}::StaticClass(); }} \\
    {class_name}(const {class_name}&) = default; \\
    {class_name}* Duplicate() const override \\
    {{ \\
        {class_name}* NewObject = ObjectFactory::DuplicateObject<{class_name}>(this); \\
        NewObject->DuplicateSubObjects(); \\
        NewObject->PostDuplicate(); \\
        return NewObject; \\
    }} \\
private: \\
    static void StaticRegisterProperties(); \\
    static const bool bPropertiesRegistered; \\
public:

// Redirect generic macro to class-specific one
#define CURRENT_CLASS_GENERATED_BODY {macro_name}_BODY
"""

# USTRUCT용 헤더 템플릿
GENERATED_STRUCT_HEADER_TEMPLATE = """// Auto-generated file - DO NOT EDIT!
// Generated by Tools/CodeGenerator/generate.py

#pragma once

// Macro expansion for GENERATED_REFLECTION_BODY()
// This file must be included BEFORE the struct definition
#ifdef CURRENT_CLASS_GENERATED_BODY
#undef CURRENT_CLASS_GENERATED_BODY
#endif
#define CURRENT_CLASS_GENERATED_BODY \\
public: \\
    using ThisClass_t = {struct_name}; \\
    static UStruct* StaticStruct() \\
    {{ \\
        static UStruct Str{{ "{struct_name}", sizeof({struct_name}) }}; \\
        static bool bRegistered = []() {{ \\
            Str.ArrayAdd = [](void* ArrayPtr) {{ \\
                static_cast<TArray<{struct_name}>*>(ArrayPtr)->Add({struct_name}()); \\
            }}; \\
            Str.ArrayRemoveAt = [](void* ArrayPtr, int32 Index) {{ \\
                static_cast<TArray<{struct_name}>*>(ArrayPtr)->RemoveAt(Index); \\
            }}; \\
            Str.ArrayInsertAt = [](void* ArrayPtr, int32 Index) {{ \\
                static_cast<TArray<{struct_name}>*>(ArrayPtr)->Insert({struct_name}(), Index); \\
            }}; \\
            Str.ArrayDuplicateAt = [](void* ArrayPtr, int32 Index) {{ \\
                auto* Arr = static_cast<TArray<{struct_name}>*>(ArrayPtr); \\
                if (Index >= 0 && Index < Arr->Num()) {{ \\
                    Arr->Insert((*Arr)[Index], Index + 1); \\
                }} \\
            }}; \\
            Str.ArrayNum = [](void* ArrayPtr) -> int32 {{ \\
                return static_cast<TArray<{struct_name}>*>(ArrayPtr)->Num(); \\
            }}; \\
            Str.ArrayGetData = [](void* ArrayPtr) -> void* {{ \\
                return static_cast<TArray<{struct_name}>*>(ArrayPtr)->GetData(); \\
            }}; \\
            Str.ArrayClear = [](void* ArrayPtr) {{ \\
                static_cast<TArray<{struct_name}>*>(ArrayPtr)->Empty(); \\
            }}; \\
            UStruct::SignUpStruct(&Str); \\
            return true; \\
        }}(); \\
        return &Str; \\
    }} \\
private: \\
    static void StaticRegisterProperties(); \\
    static const bool bPropertiesRegistered; \\
public:
"""

# USTRUCT용 CPP 템플릿
GENERATED_STRUCT_CPP_TEMPLATE = """// Auto-generated file - DO NOT EDIT!
// Generated by Tools/CodeGenerator/generate.py

#include "pch.h"
#include "{header_include}"
#include "Source/Runtime/Core/Object/ObjectMacros.h"

// Static member initialization for reflection registration
const bool {struct_name}::bPropertiesRegistered = []() {{
    {struct_name}::StaticRegisterProperties();
    return true;
}}();

// ===== Property Reflection =====
{property_code}
"""

# Enum 레지스트리 헤더 템플릿
ENUM_REGISTRY_HEADER_TEMPLATE = """// Auto-generated file - DO NOT EDIT!
// Generated by Tools/CodeGenerator/generate.py

#pragma once

#include <unordered_map>
#include <string>
#include <vector>

// ===== Enum Metadata =====
struct FEnumEntry
{
    int64_t Value;
    const char* Name;
    const char* DisplayName;
};

struct FEnumInfo
{
    const char* Name;
    const char* DisplayName;
    const char* Description;
    std::vector<FEnumEntry> Entries;
};

// ===== Enum Registry =====
class EnumRegistry
{
public:
    static EnumRegistry& Get()
    {
        static EnumRegistry Instance;
        return Instance;
    }

    void RegisterEnum(const char* EnumName, const FEnumInfo& Info)
    {
        Enums[EnumName] = Info;
    }

    const FEnumInfo* FindEnum(const char* EnumName) const
    {
        auto It = Enums.find(EnumName);
        return (It != Enums.end()) ? &It->second : nullptr;
    }

    const std::unordered_map<std::string, FEnumInfo>& GetAllEnums() const
    {
        return Enums;
    }

private:
    std::unordered_map<std::string, FEnumInfo> Enums;
};
"""

# Enum 등록 CPP 템플릿
ENUM_REGISTRATION_TEMPLATE = """// Auto-generated file - DO NOT EDIT!
// Generated by Tools/CodeGenerator/generate.py

#include "pch.h"
#include "EnumRegistry.generated.h"
{enum_includes}

// ===== Enum Registrations =====
namespace {{
{enum_registrations}
}}
"""

GENERATED_CPP_TEMPLATE = """// Auto-generated file - DO NOT EDIT!
// Generated by Tools/CodeGenerator/generate.py

#include "pch.h"
#include "{header_include}"
#include "Source/Runtime/Core/Object/ObjectMacros.h"
#include "Source/Runtime/Engine/Scripting/LuaBindHelpers.h"
{additional_includes}
// ===== Class Factory Registration (IMPLEMENT_CLASS) =====
{implement_class_code}

// ===== Property Reflection =====
{property_code}

// ===== Lua Binding =====
{lua_code}
"""


def write_file_if_different(file_path: Path, new_content: str) -> bool:
    """
    파일 내용이 실제로 다를 때만 파일을 씁니다.
    타임스탬프를 유지하여 불필요한 재컴파일을 방지합니다.

    Returns:
        True if file was written, False if content was identical
    """
    # 파일이 이미 존재하고 내용이 같으면 건너뛰기
    if file_path.exists():
        existing_content = file_path.read_text(encoding='utf-8')
        if existing_content == new_content:
            return False

    # 내용이 다르거나 파일이 없으면 쓰기
    file_path.write_text(new_content, encoding='utf-8')
    return True


def generate_header_file(class_info):
    """.generated.h 파일 생성"""
    macro_name = pascal_case_to_upper_snake(class_info.name)
    return GENERATED_HEADER_TEMPLATE.format(
        class_name=class_info.name,
        parent_class=class_info.parent,
        macro_name=macro_name
    )


def generate_implement_class(class_info):
    """IMPLEMENT_CLASS 매크로 확장 코드 생성"""
    class_name = class_info.name

    # 추상 클래스는 팩토리 함수를 nullptr로 등록 (에디터에서 직접 생성 불가)
    if class_info.is_abstract:
        factory_lambda = "nullptr"
    else:
        factory_lambda = f"[]() -> UObject* {{ return new {class_name}(); }}"

    return f"""
// IMPLEMENT_CLASS({class_name}) expansion
namespace {{
    struct {class_name}FactoryRegister
    {{
        {class_name}FactoryRegister()
        {{
            ObjectFactory::RegisterClassType(
                {class_name}::StaticClass(),
                {factory_lambda}
            );
        }}
    }};
    static {class_name}FactoryRegister GRegister_{class_name};
    static bool bIsRegistered_{class_name} = [](){{ {class_name}::StaticClass(); return true; }}();
}}

// Static member initialization for reflection registration
const bool {class_name}::bPropertiesRegistered = []() {{
    {class_name}::StaticRegisterProperties();
    return true;
}}();
"""


def generate_struct_header_file(struct_info):
    """USTRUCT용 .generated.h 파일 생성"""
    macro_name = pascal_case_to_upper_snake(struct_info.name)
    return GENERATED_STRUCT_HEADER_TEMPLATE.format(
        struct_name=struct_info.name,
        macro_name=macro_name
    )


def generate_struct_cpp_file(struct_info, prop_gen):
    """USTRUCT용 .generated.cpp 파일 생성"""
    header_include = struct_info.header_file.name
    property_code = prop_gen.generate_struct(struct_info)

    return GENERATED_STRUCT_CPP_TEMPLATE.format(
        header_include=header_include,
        struct_name=struct_info.name,
        property_code=property_code
    )


def generate_enum_registry_header():
    """EnumRegistry.generated.h 파일 생성"""
    return ENUM_REGISTRY_HEADER_TEMPLATE


def generate_enum_registration_cpp(enums):
    """EnumRegistry.generated.cpp 파일 생성"""
    if not enums:
        return ""

    # include 문 생성
    includes = set()
    for enum_info in enums:
        includes.add(f'#include "{enum_info.header_file.name}"')
    enum_includes = '\n'.join(sorted(includes))

    # enum 등록 코드 생성
    registrations = []
    for enum_info in enums:
        entries = []
        # enum_info.values는 딕셔너리 {name: int_value}
        for name, int_val in enum_info.values.items():
            display = name  # display name은 name과 동일하게 설정

            entries.append(f'            {{ {int_val}, "{name}", "{display}" }}')

        entries_str = ',\n'.join(entries)
        display_name = enum_info.display_name or enum_info.name
        description = enum_info.description or f"Auto-generated {enum_info.name}"

        registration = f'''    struct {enum_info.name}_Registrar {{
        {enum_info.name}_Registrar() {{
            FEnumInfo Info;
            Info.Name = "{enum_info.name}";
            Info.DisplayName = "{display_name}";
            Info.Description = "{description}";
            Info.Entries = {{
{entries_str}
            }};
            EnumRegistry::Get().RegisterEnum("{enum_info.name}", Info);
        }}
    }};
    static {enum_info.name}_Registrar GRegister_{enum_info.name};'''
        registrations.append(registration)

    enum_registrations = '\n\n'.join(registrations)

    return ENUM_REGISTRATION_TEMPLATE.format(
        enum_includes=enum_includes,
        enum_registrations=enum_registrations
    )


def extract_additional_includes(class_info, all_classes):
    """UFUNCTION 및 UPROPERTY에서 사용되는 타입의 헤더 파일을 자동으로 추출"""
    # 모든 클래스의 타입명 -> 헤더 파일명 매핑 생성
    type_to_header = {}
    # all_classes가 리스트인 경우 처리
    class_list = all_classes.values() if isinstance(all_classes, dict) else all_classes
    for cls in class_list:
        # 헤더 파일명만 사용 (상대 경로, 절대 경로 모두 처리)
        header_path = Path(cls.header_file)
        type_to_header[cls.name] = header_path.name  # 파일명만 추출

    required_includes = set()

    def add_include_for_type(type_str):
        """타입 문자열에서 필요한 include 추출 (파싱된 클래스 목록에서만 검색)"""
        # 포인터, const, 참조 제거
        base_type = type_str.replace('*', '').replace('const', '').replace('&', '').strip()

        # class 키워드 제거 (예: "class UPhysicalMaterial" -> "UPhysicalMaterial")
        if base_type.startswith('class '):
            base_type = base_type[6:].strip()

        # 파싱된 UCLASS/USTRUCT 목록에서만 검색 (휴리스틱 사용 안함)
        if base_type in type_to_header and base_type != class_info.name:
            required_includes.add(type_to_header[base_type])

    # UPROPERTY의 포인터 타입 검사 (Lua 바인딩에서 완전한 타입 정의 필요)
    for prop in class_info.properties:
        if '*' in prop.type:
            add_include_for_type(prop.type)

    # UFUNCTION의 반환 타입과 파라미터 타입 검사
    for func in class_info.functions:
        if func.metadata.get('lua_bind', False):
            # 반환 타입 체크
            add_include_for_type(func.return_type)

            # 파라미터 타입 체크
            for param in func.parameters:
                add_include_for_type(param.type)

    # include 문자열 생성
    if required_includes:
        include_lines = '\n'.join(f'#include "{header}"' for header in sorted(required_includes))
        return '\n' + include_lines + '\n'
    return ''


def generate_cpp_file(class_info, prop_gen, lua_gen, all_classes):
    """.generated.cpp 파일 생성"""
    # 헤더 파일 상대 경로 계산
    header_include = class_info.header_file.name

    # IMPLEMENT_CLASS 코드 생성
    implement_class_code = generate_implement_class(class_info)

    # 프로퍼티 코드 생성
    property_code = prop_gen.generate(class_info)

    # Lua 바인딩 코드 생성
    lua_code = lua_gen.generate(class_info)

    # 추가 include 생성
    additional_includes = extract_additional_includes(class_info, all_classes)

    # 최종 파일 내용
    return GENERATED_CPP_TEMPLATE.format(
        header_include=header_include,
        implement_class_code=implement_class_code,
        property_code=property_code,
        lua_code=lua_code,
        additional_includes=additional_includes
    )


def main():
    parser = argparse.ArgumentParser(
        description='Mundi Engine Lua Binding Auto-Generator'
    )
    parser.add_argument(
        '--source-dir',
        type=Path,
        required=True,
        help='소스 디렉토리 경로 (예: Source/Runtime)'
    )
    parser.add_argument(
        '--output-dir',
        type=Path,
        required=True,
        help='생성된 파일 출력 디렉토리 (예: Build/Generated)'
    )
    parser.add_argument(
        '--vcxproj',
        type=Path,
        default=None,
        help='업데이트할 .vcxproj 파일 경로 (예: Mundi.vcxproj)'
    )

    args = parser.parse_args()

    # 디렉토리 존재 확인
    if not args.source_dir.exists():
        print(f"[ERROR] Source directory not found: {args.source_dir}")
        sys.exit(1)

    # 출력 디렉토리 생성
    args.output_dir.mkdir(parents=True, exist_ok=True)

    print("=" * 60)
    print(" Mundi Engine - Code Generator")
    print("=" * 60)
    print(f" Source: {args.source_dir}")
    print(f" Output: {args.output_dir}")
    print()

    # 파서 초기화
    header_parser = HeaderParser()
    prop_gen = PropertyGenerator()
    lua_gen = LuaBindingGenerator()

    # 헤더 파일 스캔
    print(" Scanning for reflection classes...")
    all_items = header_parser.find_reflection_classes(args.source_dir)

    # 클래스와 구조체 분리
    classes = [item for item in all_items if getattr(item, 'type', 'class') == 'class']
    structs = [item for item in all_items if getattr(item, 'type', 'class') == 'struct']

    # Enum 수집 (각 클래스/구조체에서)
    all_enums = []
    for item in all_items:
        if hasattr(item, 'enums') and item.enums:
            all_enums.extend(item.enums)

    if not all_items:
        print("[WARNING] No classes/structs with GENERATED_REFLECTION_BODY() found.")
        return

    print(f"\n Found {len(classes)} class(es), {len(structs)} struct(s), {len(all_enums)} enum(s)\n")

    # PropertyGenerator에 모든 클래스 정보 전달 (상속 체인 추적용)
    prop_gen.set_all_classes(classes)

    # LuaBindingGenerator에 알려진 struct 목록 전달 (struct 타입 감지용)
    lua_gen.set_known_structs(structs)

    # 각 클래스/구조체에 대해 .generated.h와 .generated.cpp 생성
    generated_files = []
    updated_count = 0
    skipped_count = 0

    # 클래스 처리
    for class_info in classes:
        # .generated.h 파일 생성
        header_output = args.output_dir / f"{class_info.name}.generated.h"
        header_code = generate_header_file(class_info)
        header_updated = write_file_if_different(header_output, header_code)
        if header_updated:
            updated_count += 1
        generated_files.append(header_output)

        # .generated.cpp 파일 생성
        cpp_output = args.output_dir / f"{class_info.name}.generated.cpp"
        cpp_code = generate_cpp_file(class_info, prop_gen, lua_gen, classes)
        cpp_updated = write_file_if_different(cpp_output, cpp_code)
        if cpp_updated:
            updated_count += 1
        generated_files.append(cpp_output)

        # 상태 표시
        if header_updated or cpp_updated:
            status = " Updated"
        else:
            status = "  Skipped (no changes)"
            skipped_count += 1

        print(f"{status}: {class_info.name} (class)")
        if header_updated:
            print(f"  - {header_output.name} (modified)")
        if cpp_updated:
            print(f"  - {cpp_output.name} (modified)")
        print(f"  - Properties: {len(class_info.properties)}")
        print(f"  - Functions:  {len([f for f in class_info.functions if f.metadata.get('lua_bind')])}")

    # 구조체 처리
    for struct_info in structs:
        # .generated.h 파일 생성
        header_output = args.output_dir / f"{struct_info.name}.generated.h"
        header_code = generate_struct_header_file(struct_info)
        header_updated = write_file_if_different(header_output, header_code)
        if header_updated:
            updated_count += 1
        generated_files.append(header_output)

        # .generated.cpp 파일 생성
        cpp_output = args.output_dir / f"{struct_info.name}.generated.cpp"
        cpp_code = generate_struct_cpp_file(struct_info, prop_gen)
        cpp_updated = write_file_if_different(cpp_output, cpp_code)
        if cpp_updated:
            updated_count += 1
        generated_files.append(cpp_output)

        # 상태 표시
        if header_updated or cpp_updated:
            status = " Updated"
        else:
            status = "  Skipped (no changes)"
            skipped_count += 1

        print(f"{status}: {struct_info.name} (struct)")
        if header_updated:
            print(f"  - {header_output.name} (modified)")
        if cpp_updated:
            print(f"  - {cpp_output.name} (modified)")
        print(f"  - Properties: {len(struct_info.properties)}")

    # Enum 레지스트리 생성
    if all_enums:
        # EnumRegistry.generated.h
        enum_header_output = args.output_dir / "EnumRegistry.generated.h"
        enum_header_code = generate_enum_registry_header()
        enum_header_updated = write_file_if_different(enum_header_output, enum_header_code)
        if enum_header_updated:
            updated_count += 1
        generated_files.append(enum_header_output)

        # EnumRegistry.generated.cpp
        enum_cpp_output = args.output_dir / "EnumRegistry.generated.cpp"
        enum_cpp_code = generate_enum_registration_cpp(all_enums)
        enum_cpp_updated = write_file_if_different(enum_cpp_output, enum_cpp_code)
        if enum_cpp_updated:
            updated_count += 1
        generated_files.append(enum_cpp_output)

        if enum_header_updated or enum_cpp_updated:
            print(f" Updated: EnumRegistry ({len(all_enums)} enums)")
        else:
            print(f"  Skipped: EnumRegistry (no changes)")

    print()
    print("=" * 60)
    print(f" Code generation complete!")
    print(f"   Total files: {len(generated_files)}")
    print(f"   Updated: {updated_count}")
    print(f"   Skipped: {skipped_count * 2} (unchanged)")
    print("=" * 60)

    # vcxproj 업데이트
    if args.vcxproj and args.vcxproj.exists():
        print()
        print("=" * 60)
        print(" Updating Visual Studio Project...")
        print("=" * 60)

        # vcxproj_updater.py 실행
        updater_script = Path(__file__).parent / "vcxproj_updater.py"
        if updater_script.exists():
            cmd = [sys.executable, str(updater_script), str(args.vcxproj)] + [str(f) for f in generated_files]
            try:
                result = subprocess.run(cmd, capture_output=True, text=True, encoding='utf-8')
                print(result.stdout)
                if result.returncode != 0:
                    print(f"[WARNING] vcxproj update failed: {result.stderr}")
            except Exception as e:
                print(f"[WARNING] Failed to run vcxproj updater: {e}")
        else:
            print(f"[WARNING] vcxproj_updater.py not found at {updater_script}")
    elif args.vcxproj:
        print(f"\n[WARNING] vcxproj file not found: {args.vcxproj}")


if __name__ == '__main__':
    main()
