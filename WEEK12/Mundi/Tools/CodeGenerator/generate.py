#!/usr/bin/env python3
"""
Mundi Engine - Lua 바인딩 자동 생성 도구

UPROPERTY와 UFUNCTION 매크로를 파싱하여
.generated.cpp 파일을 자동 생성합니다.

사용법:
    python generate.py --source-dir <소스 디렉토리> --output-dir <출력 디렉토리>
"""

import argparse
import sys
import os
from pathlib import Path
import subprocess

# Add current script directory to Python path
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from header_parser import HeaderParser
from property_generator import PropertyGenerator
from lua_generator import LuaBindingGenerator
import re


def pascal_case_to_upper_snake(name: str) -> str:
    """
    PascalCase를 UPPER_SNAKE_CASE로 변환
    AActor -> A_ACTOR
    UActorComponent -> U_ACTOR_COMPONENT
    """
    # 대문자 앞에 언더스코어 삽입 (첫 글자 제외)
    result = re.sub(r'(?<!^)(?=[A-Z])', '_', name)
    return result.upper()


GENERATED_HEADER_TEMPLATE = """// Auto-generated file - DO NOT EDIT!
// Generated by Tools/CodeGenerator/generate.py

#pragma once

// Macro expansion for GENERATED_REFLECTION_BODY()
// This file must be included BEFORE the class definition

// Undefine previous class's macro if exists
#ifdef CURRENT_CLASS_GENERATED_BODY
#undef CURRENT_CLASS_GENERATED_BODY
#endif

// Define class-specific body macro
#define {macro_name}_BODY \\
public: \\
    using Super = {parent_class}; \\
    using ThisClass_t = {class_name}; \\
    static UClass* StaticClass() \\
    {{ \\
        static UClass Cls{{ "{class_name}", {parent_class}::StaticClass(), sizeof({class_name}) }}; \\
        static bool bRegistered = (UClass::SignUpClass(&Cls), true); \\
        return &Cls; \\
    }} \\
    virtual UClass* GetClass() const override {{ return {class_name}::StaticClass(); }} \\
    {class_name}(const {class_name}&) = default; \\
    {class_name}* Duplicate() const override \\
    {{ \\
        {class_name}* NewObject = ObjectFactory::DuplicateObject<{class_name}>(this); \\
        NewObject->DuplicateSubObjects(); \\
        NewObject->PostDuplicate(); \\
        return NewObject; \\
    }} \\
private: \\
    static void StaticRegisterProperties(); \\
    static const bool bPropertiesRegistered; \\
public:

// Redirect generic macro to class-specific one
#define CURRENT_CLASS_GENERATED_BODY {macro_name}_BODY
"""

GENERATED_CPP_TEMPLATE = """// Auto-generated file - DO NOT EDIT!
// Generated by Tools/CodeGenerator/generate.py

#include "pch.h"
#include "{header_include}"
#include "Source/Runtime/Core/Object/ObjectMacros.h"
#include "Source/Runtime/Engine/Scripting/LuaBindHelpers.h"
{additional_includes}
// ===== Class Factory Registration (IMPLEMENT_CLASS) =====
{implement_class_code}

// ===== Property Reflection =====
{property_code}

// ===== Lua Binding =====
{lua_code}
"""


def write_file_if_different(file_path: Path, new_content: str) -> bool:
    """
    파일 내용이 실제로 다를 때만 파일을 씁니다.
    타임스탬프를 유지하여 불필요한 재컴파일을 방지합니다.

    Returns:
        True if file was written, False if content was identical
    """
    # 파일이 이미 존재하고 내용이 같으면 건너뛰기
    if file_path.exists():
        existing_content = file_path.read_text(encoding='utf-8')
        if existing_content == new_content:
            return False

    # 내용이 다르거나 파일이 없으면 쓰기
    file_path.write_text(new_content, encoding='utf-8')
    return True


def generate_header_file(class_info):
    """.generated.h 파일 생성"""
    macro_name = pascal_case_to_upper_snake(class_info.name)
    return GENERATED_HEADER_TEMPLATE.format(
        class_name=class_info.name,
        parent_class=class_info.parent,
        macro_name=macro_name
    )


def generate_implement_class(class_info):
    """IMPLEMENT_CLASS 매크로 확장 코드 생성"""
    class_name = class_info.name
    return f"""
// IMPLEMENT_CLASS({class_name}) expansion
namespace {{
    struct {class_name}FactoryRegister
    {{
        {class_name}FactoryRegister()
        {{
            ObjectFactory::RegisterClassType(
                {class_name}::StaticClass(),
                []() -> UObject* {{ return new {class_name}(); }}
            );
        }}
    }};
    static {class_name}FactoryRegister GRegister_{class_name};
    static bool bIsRegistered_{class_name} = [](){{ {class_name}::StaticClass(); return true; }}();
}}

// Static member initialization for reflection registration
const bool {class_name}::bPropertiesRegistered = []() {{
    {class_name}::StaticRegisterProperties();
    return true;
}}();
"""


def find_header_file(source_dir, header_name):
    """소스 디렉토리에서 헤더 파일이 존재하는지 확인"""
    if not source_dir:
        return False

    # 소스 디렉토리 전체에서 헤더 파일 검색
    for header_path in Path(source_dir).rglob(header_name):
        if header_path.is_file():
            return True
    return False


def extract_additional_includes(class_info, all_classes, source_dir=None):
    """UFUNCTION에서 사용되는 타입의 헤더 파일을 자동으로 추출"""
    # 모든 클래스의 타입명 -> 헤더 파일명 매핑 생성
    type_to_header = {}
    # all_classes가 리스트인 경우 처리
    class_list = all_classes.values() if isinstance(all_classes, dict) else all_classes
    for cls in class_list:
        # 헤더 파일명만 사용 (상대 경로, 절대 경로 모두 처리)
        header_path = Path(cls.header_file)
        type_to_header[cls.name] = header_path.name  # 파일명만 추출

    required_includes = set()

    # UFUNCTION의 반환 타입과 파라미터 타입 검사
    for func in class_info.functions:
        if func.metadata.get('lua_bind', False):
            # 반환 타입 체크
            return_type = func.return_type.replace('*', '').replace('const', '').strip()
            if return_type in type_to_header and return_type != class_info.name:
                required_includes.add(type_to_header[return_type])
            elif return_type.startswith('U') or return_type.startswith('A') or return_type.startswith('F'):
                # U, A, F 접두사 제거하여 헤더 파일명 생성
                header_name = return_type[1:] + '.h'
                # 헤더 파일이 실제로 존재하는지 확인
                if source_dir and find_header_file(source_dir, header_name):
                    required_includes.add(header_name)

            # 파라미터 타입 체크
            for param in func.parameters:
                param_type = param.type.replace('*', '').replace('const', '').replace('&', '').strip()
                if param_type in type_to_header and param_type != class_info.name:
                    required_includes.add(type_to_header[param_type])
                elif param_type.startswith('U') or param_type.startswith('A') or param_type.startswith('F'):
                    # U, A, F 접두사 제거하여 헤더 파일명 생성
                    header_name = param_type[1:] + '.h'
                    # 헤더 파일이 실제로 존재하는지 확인
                    if source_dir and find_header_file(source_dir, header_name):
                        required_includes.add(header_name)

    # include 문자열 생성
    if required_includes:
        include_lines = '\n'.join(f'#include "{header}"' for header in sorted(required_includes))
        return '\n' + include_lines + '\n'
    return ''


def generate_cpp_file(class_info, prop_gen, lua_gen, all_classes, source_dir=None):
    """.generated.cpp 파일 생성"""
    # 헤더 파일 상대 경로 계산
    header_include = class_info.header_file.name

    # IMPLEMENT_CLASS 코드 생성
    implement_class_code = generate_implement_class(class_info)

    # 프로퍼티 코드 생성
    property_code = prop_gen.generate(class_info)

    # Lua 바인딩 코드 생성
    lua_code = lua_gen.generate(class_info)

    # 추가 include 생성 (all_classes와 source_dir 전달)
    additional_includes = extract_additional_includes(class_info, all_classes, source_dir)

    # 최종 파일 내용
    return GENERATED_CPP_TEMPLATE.format(
        header_include=header_include,
        implement_class_code=implement_class_code,
        property_code=property_code,
        lua_code=lua_code,
        additional_includes=additional_includes
    )


def main():
    parser = argparse.ArgumentParser(
        description='Mundi Engine Lua Binding Auto-Generator'
    )
    parser.add_argument(
        '--source-dir',
        type=Path,
        required=True,
        help='소스 디렉토리 경로 (예: Source/Runtime)'
    )
    parser.add_argument(
        '--output-dir',
        type=Path,
        required=True,
        help='생성된 파일 출력 디렉토리 (예: Build/Generated)'
    )
    parser.add_argument(
        '--vcxproj',
        type=Path,
        default=None,
        help='업데이트할 .vcxproj 파일 경로 (예: Mundi.vcxproj)'
    )

    args = parser.parse_args()

    # 디렉토리 존재 확인
    if not args.source_dir.exists():
        print(f"[ERROR] Source directory not found: {args.source_dir}")
        sys.exit(1)

    # 출력 디렉토리 생성
    args.output_dir.mkdir(parents=True, exist_ok=True)

    print("=" * 60)
    print(" Mundi Engine - Code Generator")
    print("=" * 60)
    print(f" Source: {args.source_dir}")
    print(f" Output: {args.output_dir}")
    print()

    # 파서 초기화
    header_parser = HeaderParser()
    prop_gen = PropertyGenerator()
    lua_gen = LuaBindingGenerator()

    # 헤더 파일 스캔
    print(" Scanning for reflection classes...")
    classes = header_parser.find_reflection_classes(args.source_dir)

    if not classes:
        print("[WARNING] No classes with GENERATED_REFLECTION_BODY() found.")
        return

    print(f"\n Found {len(classes)} reflection class(es)\n")

    # PropertyGenerator에 모든 클래스 정보 전달 (상속 체인 추적용)
    prop_gen.set_all_classes(classes)

    # 각 클래스에 대해 .generated.h와 .generated.cpp 생성
    generated_files = []
    updated_count = 0
    skipped_count = 0

    for class_info in classes:
        # .generated.h 파일 생성
        header_output = args.output_dir / f"{class_info.name}.generated.h"
        header_code = generate_header_file(class_info)
        header_updated = write_file_if_different(header_output, header_code)
        if header_updated:
            updated_count += 1
        generated_files.append(header_output)

        # .generated.cpp 파일 생성
        cpp_output = args.output_dir / f"{class_info.name}.generated.cpp"
        cpp_code = generate_cpp_file(class_info, prop_gen, lua_gen, classes, args.source_dir)
        cpp_updated = write_file_if_different(cpp_output, cpp_code)
        if cpp_updated:
            updated_count += 1
        generated_files.append(cpp_output)

        # 상태 표시
        if header_updated or cpp_updated:
            status = " Updated"
        else:
            status = "  Skipped (no changes)"
            skipped_count += 1

        print(f"{status}: {class_info.name}")
        if header_updated:
            print(f"  - {header_output.name} (modified)")
        if cpp_updated:
            print(f"  - {cpp_output.name} (modified)")
        print(f"  - Properties: {len(class_info.properties)}")
        print(f"  - Functions:  {len([f for f in class_info.functions if f.metadata.get('lua_bind')])}")

    print()
    print("=" * 60)
    print(f" Code generation complete!")
    print(f"   Total files: {len(generated_files)}")
    print(f"   Updated: {updated_count}")
    print(f"   Skipped: {skipped_count * 2} (unchanged)")
    print("=" * 60)

    # vcxproj 업데이트
    if args.vcxproj and args.vcxproj.exists():
        print()
        print("=" * 60)
        print(" Updating Visual Studio Project...")
        print("=" * 60)

        # vcxproj_updater.py 실행
        updater_script = Path(__file__).parent / "vcxproj_updater.py"
        if updater_script.exists():
            cmd = [sys.executable, str(updater_script), str(args.vcxproj)] + [str(f) for f in generated_files]
            try:
                result = subprocess.run(cmd, capture_output=True, text=True, encoding='utf-8')
                print(result.stdout)
                if result.returncode != 0:
                    print(f"[WARNING] vcxproj update failed: {result.stderr}")
            except Exception as e:
                print(f"[WARNING] Failed to run vcxproj updater: {e}")
        else:
            print(f"[WARNING] vcxproj_updater.py not found at {updater_script}")
    elif args.vcxproj:
        print(f"\n[WARNING] vcxproj file not found: {args.vcxproj}")


if __name__ == '__main__':
    main()
